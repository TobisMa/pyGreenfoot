<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygreenfoot.world API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygreenfoot.world</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABCMeta
from collections import defaultdict
from functools import cached_property
from time import time
from typing import (DefaultDict, Dict, Generator, List, Optional, Set, Tuple,
                    Type, Union)

import pygame

from . import get_resource_path, keys
from .actor import Actor
from .color import Color
from .font import Font, Text
from .image import Image
from .__types import _ActorType


class World(metaclass=ABCMeta):
    
    __slots__ = (&#34;__size&#34;, &#34;world_bounding&#34;, &#34;__cell_size&#34;, &#34;__objects&#34;, &#34;__texts&#34;,
                 &#34;__existing_object_types&#34;, &#34;__act_order&#34;, &#34;__paint_order&#34;, &#34;__world_speed&#34;
                 &#34;__background&#34;, &#34;__canvas&#34;, &#34;__half_cell&#34;, &#34;__app&#34;, &#34;running&#34;, &#34;__last_time&#34;)
    
    def __init__(self, width: int, height: int, cell_size: int, world_bounding: bool = True) -&gt; None:
        from .application import Application
        self.__size = (width, height)
        self.__cell_size: int = cell_size
        self.world_bounding: bool = world_bounding
        self.__act_order: List[Type[Actor]] = []
        self.__paint_order: List[Type[Actor]] = []
        self.__objects: DefaultDict[Type[Actor], Set[Actor]] = defaultdict(set)
        self.__existing_object_types = set()
        self.__background: Optional[Image] = None
        self.__canvas: pygame.surface.Surface = pygame.Surface((width * cell_size, height * cell_size))
        self.__half_cell: int = self.__cell_size // 2
        self.__app = Application.get_app()
        self.__texts: Dict[Tuple[int, int], Tuple[Text, Tuple[int, int]]] = {}
        self.running: bool = True
        self.world_speed: float = self.__app.default_world_speed
        self.__last_time = time()
        
    def add_to_world(self, game_object: &#34;Actor&#34;, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Adds an actor to this world instance

        Args:
            actor (Actor): The actor which will be added to this world instance

        Raises:
            TypeError: if the passed argument is not inheriting from pygreenfoot.Actor
        &#34;&#34;&#34;
        if not isinstance(game_object, Actor):
            raise TypeError(&#34;Only subclasses of Actor can be added to world&#34;)
        self.__objects[type(game_object)].add(game_object)
        self.__existing_object_types.add(type(game_object))
        game_object.set_position(x, y)
        game_object.on_world_add(self)
        
    @cached_property
    def width(self) -&gt; int:
        &#34;&#34;&#34;width of this world instance

        Returns:
            int: the world width in cells
        &#34;&#34;&#34;
        return int(self.__size[0])
    
    @cached_property
    def height(self) -&gt; int:
        &#34;&#34;&#34;height of this world instance

        Returns:
            int: the world height in cells
        &#34;&#34;&#34;
        return int(self.__size[1])
    
    @cached_property
    def cell_size(self) -&gt; int:
        &#34;&#34;&#34;how large one cell (always quadratic) is in pixel

        Returns:
            int: the width and height of the cell
        &#34;&#34;&#34;
        return self.__cell_size
    
    def _check_world_time(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the next frame shall be exexcuted

        Returns:
            bool: True if the next act_cycle shall be exexcuted or False if the world time still needs to be awaited
        &#34;&#34;&#34;
        return time() - self.__last_time &lt;= self.world_speed
    
    def _calc_frame(self) -&gt; None:
        &#34;&#34;&#34;
        Runs the act cylces if necessary
        &#34;&#34;&#34;
        if self.running and self._check_world_time():
            self.__act_cycle()
            self.repaint()
            self.__last_time = time()
            
        elif not self.running and self.__app.get_key_states(keys.K_SPACE)[0]:
            self.running = True
        
                
    def repaint(self, only_background: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Redraws the whole world
        &#34;&#34;&#34;
        if self.__background is not None:
            self.__canvas.blit(self.__background._surface, (0, 0))
        
        if only_background:
            return
        
        done: Set[Type[Actor]] = set()
        for object_type in self.__paint_order:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.repaint()
        
        for object_type in set(self.__objects) - done:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.repaint()
        
        for text, pos in self.__texts.values():
            self.__canvas.blit(text._surface, pos)
                
    def __act_cycle(self) -&gt; None:
        self.act()
        done: Set[Type[Actor]] = set()
        for object_type in self.__act_order:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.act()
        
        for object_type in set(self.__objects) - done:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.act()
            
    
    def act(self) -&gt; None:
        &#34;&#34;&#34;
        Called once per frame by the main application.
        Subclasses can override this method.
        The default does nothing
        &#34;&#34;&#34;
        pass
    
    def set_act_order(self, *act_order: Type[Actor]) -&gt; None:
        &#34;&#34;&#34;Sets the order in which the actor&#39;s act methods are called

        Args:
            act_order (Iterable): an iterable of types of actors to specify in which order they should be drawn.
                It is not possible to influence the draw order of two actors with the same type.
        &#34;&#34;&#34;
        self.__act_order = list(act_order)
        
    def get_act_order(self) -&gt; List[Type[Actor]]:
        &#34;&#34;&#34;Returns the current set act order

        Returns:
            List[Type[Actor]]: the order the objects will be sorted. Types of actors which are not within the returned list will be drawn in an random order.
        &#34;&#34;&#34;
        return self.__act_order
    
    def set_paint_order(self, *paint_order: Type[Actor]) -&gt; None:
        &#34;&#34;&#34;Sets the paint order of actor types. It is not possible to influence the draw order of two actors with the same type

        Args:
            paint_order (Iterable[Type[Actor]]): an iterable of types of actors
        &#34;&#34;&#34;
        self.__paint_order = list(paint_order)
        
    def get_paint_order(self) -&gt; List[Type[Actor]]:
        &#34;&#34;&#34;Returns the paint order

        Returns:
            List[Type[Actor]]: the current paint order. If a type of actor is missing within this list this type of actor will
                be drawn after all listed types at an certain point within each frame
        &#34;&#34;&#34;
        return self.__paint_order
    
    def set_background(self, filename_or_image: Union[str, pygame.Surface], scale_to_cell_size: bool = False) -&gt; None:
        &#34;&#34;&#34;Set an background image for the world. If the image is too small for the world it will be repeated in vertical 
        and horizontal direction until it covers all cells of the world.

        Args:
            filename_or_image (Union[str, pygame.Surface]): a str used as path (default directory is &#39;images&#39;) or an pygame.Surface object
            scale_to_cell_size (bool): scales the image to the cell size if True. Default is False.

        Raises:
            FileNotFoundError: if the argument is a string, but an invalid filename
        &#34;&#34;&#34;
        if isinstance(filename_or_image, str):
            path = get_resource_path(filename_or_image, &#34;image&#34;)

            image: pygame.surface.Surface = pygame.image.load(path)
            
        else:
            image: pygame.surface.Surface = filename_or_image
        
        bg = pygame.Surface((self.width * self.cell_size, self.height * self.cell_size))
        wr = range(0, self.cell_size * self.width + self.cell_size, image.get_width())
        hr = range(0, self.cell_size * self.height + self.cell_size, image.get_height())
        
        for x in wr:
            for y in hr:
                bg.blit(image.copy(), (x, y))
        
        self.__background = Image(bg)
        
    def get_background_image(self) -&gt; Image:
        &#34;&#34;&#34;Returns the rendered background image

        Returns:
            Image: the background image drawn on the surface
        &#34;&#34;&#34;
        if self.__background is None:
            s = pygame.Surface((self.__cell_size * self.width, self.__cell_size * self.height))
            s.fill(Color.WHITE._pygame)
            return Image(s)
        return self.__background
            
    def get_color_at(self, x: int, y: int) -&gt; Color:
        &#34;&#34;&#34;Return the color at the center of the cell (x, y). Objects drawn on the background are considered.

        Args:
            x (int): the x coordinate of the cell
            y (int): the y coordinate of the cell

        Returns:
            Color: the color at the center of the cell
        &#34;&#34;&#34;
        return Color.from_pygame_color(
            self.__canvas.get_at(  # type: ignore
                (x * self.__cell_size + self.__half_cell, y * self.__cell_size + self.__half_cell)
            )
        )
    
    def get_actors(self, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Return all actors currently existing in the world

        Args:
            type_ (Optional[Type[Actor]], optional): an argument to filter for a specific type of actors. Defaults to None.

        Returns:
            List[Actor]: the actors having type type_ or all actors within the world in case type_=None
        &#34;&#34;&#34;
        return list(self.get_actors_generator(type_))
        
    def get_actors_generator(self, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;
        the same as get_actors but returns a generator object
        &#34;&#34;&#34;
        if type_ is None:
            for actor_set in self.__objects.values():
                yield from actor_set  # type: ignore
        else:
            yield from self.__objects[type_]  # type: ignore
                
    def get_objects_at(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Return all objects at the position (x, y) having the type type_

        Args:
            x (int): the x coorindate of the actor
            y (int): the y coordinate of the actor
            type_ (Optional[Type[Actor]], optional): the type the actor must have. Defaults to None.

        Returns:
            List[Actor]: a list of all actors at the position (x, y) having the type type_ or just all types if type_ is None
        &#34;&#34;&#34;
        return list(self.get_objects_at_generator(x, y, type_))
    
    def get_objects_at_generator(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:        
        &#34;&#34;&#34;
        The same as get_objects_at but returns a generator
        &#34;&#34;&#34;
        area = pygame.Rect(x * self.__cell_size, y * self.__cell_size, self.__cell_size, self.__cell_size)
        if type_ is None:
            for actor_type in self.__objects:
                yield from self.get_objects_at_generator(x, y, actor_type) # type: ignore
        else:
            for actor in self.__objects[type_]:
                if actor._rect.colliderect(area):
                    yield actor  # type: ignore
                    
    def remove_from_world(self, *actors: Actor) -&gt; None:
        &#34;&#34;&#34;
        Removes the given actor(s) from the world
        &#34;&#34;&#34;
        for actor in actors:
            actor.on_world_remove()
            self.__objects[type(actor)].remove(actor)
                        
    def number_of_actors(self) -&gt; int:
        &#34;&#34;&#34;Counts the actors existing currently in this world

        Returns:
            int: the amount of actors in the world
        &#34;&#34;&#34;
        return sum(len(actor_set) for actor_set in self.__objects.values())

    def show_text(self, text: Optional[Union[str, Text]], x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Adds the text to the cell (x, y)

        Args:
            text (Optional[str]): the text to be shown at cell (x, y). If the text is None it will be removed
            x (int): the x position of the cell
            y (int): the y position of the cell
        &#34;&#34;&#34;
        if text is None:
            self.__texts.pop((x, y), None)
            return
        
        if isinstance(text, str):
            font = Font(Font.get_default_font(), 26)
            width, height = font._pygame.size(text)
        else:
            width, height = text.font._pygame.size(text.display_text)
            
        px: int = x * self.__cell_size + self.__half_cell - width // 2
        py: int = y * self.__cell_size + self.__half_cell - height // 2
        
        if isinstance(text, str):
            text: Text = font.get_text(text, Color(0, 0, 0), True)  # type: ignore
            
        self.__texts[(x, y)] = text, (px, py)
            
            
        
    def get_text_at(self, x: int, y: int) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the text at the cell (x, y)

        Args:
            x (int): the x position of the cell
            y (int): the y position of the cell

        Returns:
            Optional[str]: the text at the cell or if no text is found, this function will return None
        &#34;&#34;&#34;
        value = self.__texts.get((x, y))
        return None if value is None else value[0].display_text
    
    @property
    def _rect(self) -&gt; pygame.Rect:
        &#34;&#34;&#34;
        pygame.Rect of the world
        &#34;&#34;&#34;
        return pygame.Rect(0, 0, self.width * self.cell_size, self.height * self.cell_size)
    
    @property
    def _surface(self) -&gt; pygame.surface.Surface:
        &#34;&#34;&#34;
        The pygame&#39;s world surface
        &#34;&#34;&#34;
        return self.__canvas</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygreenfoot.world.World"><code class="flex name class">
<span>class <span class="ident">World</span></span>
<span>(</span><span>width: int, height: int, cell_size: int, world_bounding: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class World(metaclass=ABCMeta):
    
    __slots__ = (&#34;__size&#34;, &#34;world_bounding&#34;, &#34;__cell_size&#34;, &#34;__objects&#34;, &#34;__texts&#34;,
                 &#34;__existing_object_types&#34;, &#34;__act_order&#34;, &#34;__paint_order&#34;, &#34;__world_speed&#34;
                 &#34;__background&#34;, &#34;__canvas&#34;, &#34;__half_cell&#34;, &#34;__app&#34;, &#34;running&#34;, &#34;__last_time&#34;)
    
    def __init__(self, width: int, height: int, cell_size: int, world_bounding: bool = True) -&gt; None:
        from .application import Application
        self.__size = (width, height)
        self.__cell_size: int = cell_size
        self.world_bounding: bool = world_bounding
        self.__act_order: List[Type[Actor]] = []
        self.__paint_order: List[Type[Actor]] = []
        self.__objects: DefaultDict[Type[Actor], Set[Actor]] = defaultdict(set)
        self.__existing_object_types = set()
        self.__background: Optional[Image] = None
        self.__canvas: pygame.surface.Surface = pygame.Surface((width * cell_size, height * cell_size))
        self.__half_cell: int = self.__cell_size // 2
        self.__app = Application.get_app()
        self.__texts: Dict[Tuple[int, int], Tuple[Text, Tuple[int, int]]] = {}
        self.running: bool = True
        self.world_speed: float = self.__app.default_world_speed
        self.__last_time = time()
        
    def add_to_world(self, game_object: &#34;Actor&#34;, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Adds an actor to this world instance

        Args:
            actor (Actor): The actor which will be added to this world instance

        Raises:
            TypeError: if the passed argument is not inheriting from pygreenfoot.Actor
        &#34;&#34;&#34;
        if not isinstance(game_object, Actor):
            raise TypeError(&#34;Only subclasses of Actor can be added to world&#34;)
        self.__objects[type(game_object)].add(game_object)
        self.__existing_object_types.add(type(game_object))
        game_object.set_position(x, y)
        game_object.on_world_add(self)
        
    @cached_property
    def width(self) -&gt; int:
        &#34;&#34;&#34;width of this world instance

        Returns:
            int: the world width in cells
        &#34;&#34;&#34;
        return int(self.__size[0])
    
    @cached_property
    def height(self) -&gt; int:
        &#34;&#34;&#34;height of this world instance

        Returns:
            int: the world height in cells
        &#34;&#34;&#34;
        return int(self.__size[1])
    
    @cached_property
    def cell_size(self) -&gt; int:
        &#34;&#34;&#34;how large one cell (always quadratic) is in pixel

        Returns:
            int: the width and height of the cell
        &#34;&#34;&#34;
        return self.__cell_size
    
    def _check_world_time(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the next frame shall be exexcuted

        Returns:
            bool: True if the next act_cycle shall be exexcuted or False if the world time still needs to be awaited
        &#34;&#34;&#34;
        return time() - self.__last_time &lt;= self.world_speed
    
    def _calc_frame(self) -&gt; None:
        &#34;&#34;&#34;
        Runs the act cylces if necessary
        &#34;&#34;&#34;
        if self.running and self._check_world_time():
            self.__act_cycle()
            self.repaint()
            self.__last_time = time()
            
        elif not self.running and self.__app.get_key_states(keys.K_SPACE)[0]:
            self.running = True
        
                
    def repaint(self, only_background: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Redraws the whole world
        &#34;&#34;&#34;
        if self.__background is not None:
            self.__canvas.blit(self.__background._surface, (0, 0))
        
        if only_background:
            return
        
        done: Set[Type[Actor]] = set()
        for object_type in self.__paint_order:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.repaint()
        
        for object_type in set(self.__objects) - done:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.repaint()
        
        for text, pos in self.__texts.values():
            self.__canvas.blit(text._surface, pos)
                
    def __act_cycle(self) -&gt; None:
        self.act()
        done: Set[Type[Actor]] = set()
        for object_type in self.__act_order:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.act()
        
        for object_type in set(self.__objects) - done:
            done.add(object_type)
            for game_object in self.__objects[object_type]:
                game_object.act()
            
    
    def act(self) -&gt; None:
        &#34;&#34;&#34;
        Called once per frame by the main application.
        Subclasses can override this method.
        The default does nothing
        &#34;&#34;&#34;
        pass
    
    def set_act_order(self, *act_order: Type[Actor]) -&gt; None:
        &#34;&#34;&#34;Sets the order in which the actor&#39;s act methods are called

        Args:
            act_order (Iterable): an iterable of types of actors to specify in which order they should be drawn.
                It is not possible to influence the draw order of two actors with the same type.
        &#34;&#34;&#34;
        self.__act_order = list(act_order)
        
    def get_act_order(self) -&gt; List[Type[Actor]]:
        &#34;&#34;&#34;Returns the current set act order

        Returns:
            List[Type[Actor]]: the order the objects will be sorted. Types of actors which are not within the returned list will be drawn in an random order.
        &#34;&#34;&#34;
        return self.__act_order
    
    def set_paint_order(self, *paint_order: Type[Actor]) -&gt; None:
        &#34;&#34;&#34;Sets the paint order of actor types. It is not possible to influence the draw order of two actors with the same type

        Args:
            paint_order (Iterable[Type[Actor]]): an iterable of types of actors
        &#34;&#34;&#34;
        self.__paint_order = list(paint_order)
        
    def get_paint_order(self) -&gt; List[Type[Actor]]:
        &#34;&#34;&#34;Returns the paint order

        Returns:
            List[Type[Actor]]: the current paint order. If a type of actor is missing within this list this type of actor will
                be drawn after all listed types at an certain point within each frame
        &#34;&#34;&#34;
        return self.__paint_order
    
    def set_background(self, filename_or_image: Union[str, pygame.Surface], scale_to_cell_size: bool = False) -&gt; None:
        &#34;&#34;&#34;Set an background image for the world. If the image is too small for the world it will be repeated in vertical 
        and horizontal direction until it covers all cells of the world.

        Args:
            filename_or_image (Union[str, pygame.Surface]): a str used as path (default directory is &#39;images&#39;) or an pygame.Surface object
            scale_to_cell_size (bool): scales the image to the cell size if True. Default is False.

        Raises:
            FileNotFoundError: if the argument is a string, but an invalid filename
        &#34;&#34;&#34;
        if isinstance(filename_or_image, str):
            path = get_resource_path(filename_or_image, &#34;image&#34;)

            image: pygame.surface.Surface = pygame.image.load(path)
            
        else:
            image: pygame.surface.Surface = filename_or_image
        
        bg = pygame.Surface((self.width * self.cell_size, self.height * self.cell_size))
        wr = range(0, self.cell_size * self.width + self.cell_size, image.get_width())
        hr = range(0, self.cell_size * self.height + self.cell_size, image.get_height())
        
        for x in wr:
            for y in hr:
                bg.blit(image.copy(), (x, y))
        
        self.__background = Image(bg)
        
    def get_background_image(self) -&gt; Image:
        &#34;&#34;&#34;Returns the rendered background image

        Returns:
            Image: the background image drawn on the surface
        &#34;&#34;&#34;
        if self.__background is None:
            s = pygame.Surface((self.__cell_size * self.width, self.__cell_size * self.height))
            s.fill(Color.WHITE._pygame)
            return Image(s)
        return self.__background
            
    def get_color_at(self, x: int, y: int) -&gt; Color:
        &#34;&#34;&#34;Return the color at the center of the cell (x, y). Objects drawn on the background are considered.

        Args:
            x (int): the x coordinate of the cell
            y (int): the y coordinate of the cell

        Returns:
            Color: the color at the center of the cell
        &#34;&#34;&#34;
        return Color.from_pygame_color(
            self.__canvas.get_at(  # type: ignore
                (x * self.__cell_size + self.__half_cell, y * self.__cell_size + self.__half_cell)
            )
        )
    
    def get_actors(self, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Return all actors currently existing in the world

        Args:
            type_ (Optional[Type[Actor]], optional): an argument to filter for a specific type of actors. Defaults to None.

        Returns:
            List[Actor]: the actors having type type_ or all actors within the world in case type_=None
        &#34;&#34;&#34;
        return list(self.get_actors_generator(type_))
        
    def get_actors_generator(self, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;
        the same as get_actors but returns a generator object
        &#34;&#34;&#34;
        if type_ is None:
            for actor_set in self.__objects.values():
                yield from actor_set  # type: ignore
        else:
            yield from self.__objects[type_]  # type: ignore
                
    def get_objects_at(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Return all objects at the position (x, y) having the type type_

        Args:
            x (int): the x coorindate of the actor
            y (int): the y coordinate of the actor
            type_ (Optional[Type[Actor]], optional): the type the actor must have. Defaults to None.

        Returns:
            List[Actor]: a list of all actors at the position (x, y) having the type type_ or just all types if type_ is None
        &#34;&#34;&#34;
        return list(self.get_objects_at_generator(x, y, type_))
    
    def get_objects_at_generator(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:        
        &#34;&#34;&#34;
        The same as get_objects_at but returns a generator
        &#34;&#34;&#34;
        area = pygame.Rect(x * self.__cell_size, y * self.__cell_size, self.__cell_size, self.__cell_size)
        if type_ is None:
            for actor_type in self.__objects:
                yield from self.get_objects_at_generator(x, y, actor_type) # type: ignore
        else:
            for actor in self.__objects[type_]:
                if actor._rect.colliderect(area):
                    yield actor  # type: ignore
                    
    def remove_from_world(self, *actors: Actor) -&gt; None:
        &#34;&#34;&#34;
        Removes the given actor(s) from the world
        &#34;&#34;&#34;
        for actor in actors:
            actor.on_world_remove()
            self.__objects[type(actor)].remove(actor)
                        
    def number_of_actors(self) -&gt; int:
        &#34;&#34;&#34;Counts the actors existing currently in this world

        Returns:
            int: the amount of actors in the world
        &#34;&#34;&#34;
        return sum(len(actor_set) for actor_set in self.__objects.values())

    def show_text(self, text: Optional[Union[str, Text]], x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Adds the text to the cell (x, y)

        Args:
            text (Optional[str]): the text to be shown at cell (x, y). If the text is None it will be removed
            x (int): the x position of the cell
            y (int): the y position of the cell
        &#34;&#34;&#34;
        if text is None:
            self.__texts.pop((x, y), None)
            return
        
        if isinstance(text, str):
            font = Font(Font.get_default_font(), 26)
            width, height = font._pygame.size(text)
        else:
            width, height = text.font._pygame.size(text.display_text)
            
        px: int = x * self.__cell_size + self.__half_cell - width // 2
        py: int = y * self.__cell_size + self.__half_cell - height // 2
        
        if isinstance(text, str):
            text: Text = font.get_text(text, Color(0, 0, 0), True)  # type: ignore
            
        self.__texts[(x, y)] = text, (px, py)
            
            
        
    def get_text_at(self, x: int, y: int) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the text at the cell (x, y)

        Args:
            x (int): the x position of the cell
            y (int): the y position of the cell

        Returns:
            Optional[str]: the text at the cell or if no text is found, this function will return None
        &#34;&#34;&#34;
        value = self.__texts.get((x, y))
        return None if value is None else value[0].display_text
    
    @property
    def _rect(self) -&gt; pygame.Rect:
        &#34;&#34;&#34;
        pygame.Rect of the world
        &#34;&#34;&#34;
        return pygame.Rect(0, 0, self.width * self.cell_size, self.height * self.cell_size)
    
    @property
    def _surface(self) -&gt; pygame.surface.Surface:
        &#34;&#34;&#34;
        The pygame&#39;s world surface
        &#34;&#34;&#34;
        return self.__canvas</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pygreenfoot.world.World.cell_size"><code class="name">var <span class="ident">cell_size</span></code></dt>
<dd>
<div class="desc"><p>how large one cell (always quadratic) is in pixel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the width and height of the cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>height of this world instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the world height in cells</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.running"><code class="name">var <span class="ident">running</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pygreenfoot.world.World.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>width of this world instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the world width in cells</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.world_bounding"><code class="name">var <span class="ident">world_bounding</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygreenfoot.world.World.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called once per frame by the main application.
Subclasses can override this method.
The default does nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def act(self) -&gt; None:
    &#34;&#34;&#34;
    Called once per frame by the main application.
    Subclasses can override this method.
    The default does nothing
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.add_to_world"><code class="name flex">
<span>def <span class="ident">add_to_world</span></span>(<span>self, game_object: Actor, x: int, y: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an actor to this world instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>actor</code></strong> :&ensp;<code>Actor</code></dt>
<dd>The actor which will be added to this world instance</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if the passed argument is not inheriting from pygreenfoot.Actor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_world(self, game_object: &#34;Actor&#34;, x: int, y: int) -&gt; None:
    &#34;&#34;&#34;Adds an actor to this world instance

    Args:
        actor (Actor): The actor which will be added to this world instance

    Raises:
        TypeError: if the passed argument is not inheriting from pygreenfoot.Actor
    &#34;&#34;&#34;
    if not isinstance(game_object, Actor):
        raise TypeError(&#34;Only subclasses of Actor can be added to world&#34;)
    self.__objects[type(game_object)].add(game_object)
    self.__existing_object_types.add(type(game_object))
    game_object.set_position(x, y)
    game_object.on_world_add(self)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_act_order"><code class="name flex">
<span>def <span class="ident">get_act_order</span></span>(<span>self) ‑> List[Type[<a title="pygreenfoot.actor.Actor" href="actor.html#pygreenfoot.actor.Actor">Actor</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current set act order</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Type[Actor]]</code></dt>
<dd>the order the objects will be sorted. Types of actors which are not within the returned list will be drawn in an random order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_act_order(self) -&gt; List[Type[Actor]]:
    &#34;&#34;&#34;Returns the current set act order

    Returns:
        List[Type[Actor]]: the order the objects will be sorted. Types of actors which are not within the returned list will be drawn in an random order.
    &#34;&#34;&#34;
    return self.__act_order</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_actors"><code class="name flex">
<span>def <span class="ident">get_actors</span></span>(<span>self, type_: Optional[Type[~_ActorType]] = None) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all actors currently existing in the world</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_</code></strong> :&ensp;<code>Optional[Type[Actor]]</code>, optional</dt>
<dd>an argument to filter for a specific type of actors. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Actor]</code></dt>
<dd>the actors having type type_ or all actors within the world in case type_=None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors(self, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
    &#34;&#34;&#34;Return all actors currently existing in the world

    Args:
        type_ (Optional[Type[Actor]], optional): an argument to filter for a specific type of actors. Defaults to None.

    Returns:
        List[Actor]: the actors having type type_ or all actors within the world in case type_=None
    &#34;&#34;&#34;
    return list(self.get_actors_generator(type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_actors_generator"><code class="name flex">
<span>def <span class="ident">get_actors_generator</span></span>(<span>self, type_: Optional[Type[~_ActorType]] = None) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>the same as get_actors but returns a generator object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors_generator(self, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
    &#34;&#34;&#34;
    the same as get_actors but returns a generator object
    &#34;&#34;&#34;
    if type_ is None:
        for actor_set in self.__objects.values():
            yield from actor_set  # type: ignore
    else:
        yield from self.__objects[type_]  # type: ignore</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_background_image"><code class="name flex">
<span>def <span class="ident">get_background_image</span></span>(<span>self) ‑> <a title="pygreenfoot.image.Image" href="image.html#pygreenfoot.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the rendered background image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Image</code></dt>
<dd>the background image drawn on the surface</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_image(self) -&gt; Image:
    &#34;&#34;&#34;Returns the rendered background image

    Returns:
        Image: the background image drawn on the surface
    &#34;&#34;&#34;
    if self.__background is None:
        s = pygame.Surface((self.__cell_size * self.width, self.__cell_size * self.height))
        s.fill(Color.WHITE._pygame)
        return Image(s)
    return self.__background</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_color_at"><code class="name flex">
<span>def <span class="ident">get_color_at</span></span>(<span>self, x: int, y: int) ‑> <a title="pygreenfoot.color.Color" href="color.html#pygreenfoot.color.Color">Color</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the color at the center of the cell (x, y). Objects drawn on the background are considered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>the x coordinate of the cell</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>the y coordinate of the cell</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Color</code></dt>
<dd>the color at the center of the cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_color_at(self, x: int, y: int) -&gt; Color:
    &#34;&#34;&#34;Return the color at the center of the cell (x, y). Objects drawn on the background are considered.

    Args:
        x (int): the x coordinate of the cell
        y (int): the y coordinate of the cell

    Returns:
        Color: the color at the center of the cell
    &#34;&#34;&#34;
    return Color.from_pygame_color(
        self.__canvas.get_at(  # type: ignore
            (x * self.__cell_size + self.__half_cell, y * self.__cell_size + self.__half_cell)
        )
    )</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_objects_at"><code class="name flex">
<span>def <span class="ident">get_objects_at</span></span>(<span>self, x: int, y: int, type_: Optional[Type[~_ActorType]] = None) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all objects at the position (x, y) having the type type_</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>the x coorindate of the actor</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>the y coordinate of the actor</dd>
<dt><strong><code>type_</code></strong> :&ensp;<code>Optional[Type[Actor]]</code>, optional</dt>
<dd>the type the actor must have. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Actor]</code></dt>
<dd>a list of all actors at the position (x, y) having the type type_ or just all types if type_ is None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_objects_at(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
    &#34;&#34;&#34;Return all objects at the position (x, y) having the type type_

    Args:
        x (int): the x coorindate of the actor
        y (int): the y coordinate of the actor
        type_ (Optional[Type[Actor]], optional): the type the actor must have. Defaults to None.

    Returns:
        List[Actor]: a list of all actors at the position (x, y) having the type type_ or just all types if type_ is None
    &#34;&#34;&#34;
    return list(self.get_objects_at_generator(x, y, type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_objects_at_generator"><code class="name flex">
<span>def <span class="ident">get_objects_at_generator</span></span>(<span>self, x: int, y: int, type_: Optional[Type[~_ActorType]] = None) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>The same as get_objects_at but returns a generator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_objects_at_generator(self, x: int, y: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:        
    &#34;&#34;&#34;
    The same as get_objects_at but returns a generator
    &#34;&#34;&#34;
    area = pygame.Rect(x * self.__cell_size, y * self.__cell_size, self.__cell_size, self.__cell_size)
    if type_ is None:
        for actor_type in self.__objects:
            yield from self.get_objects_at_generator(x, y, actor_type) # type: ignore
    else:
        for actor in self.__objects[type_]:
            if actor._rect.colliderect(area):
                yield actor  # type: ignore</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_paint_order"><code class="name flex">
<span>def <span class="ident">get_paint_order</span></span>(<span>self) ‑> List[Type[<a title="pygreenfoot.actor.Actor" href="actor.html#pygreenfoot.actor.Actor">Actor</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the paint order</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Type[Actor]]</code></dt>
<dd>the current paint order. If a type of actor is missing within this list this type of actor will
be drawn after all listed types at an certain point within each frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paint_order(self) -&gt; List[Type[Actor]]:
    &#34;&#34;&#34;Returns the paint order

    Returns:
        List[Type[Actor]]: the current paint order. If a type of actor is missing within this list this type of actor will
            be drawn after all listed types at an certain point within each frame
    &#34;&#34;&#34;
    return self.__paint_order</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.get_text_at"><code class="name flex">
<span>def <span class="ident">get_text_at</span></span>(<span>self, x: int, y: int) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the text at the cell (x, y)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>the x position of the cell</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>the y position of the cell</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>the text at the cell or if no text is found, this function will return None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_at(self, x: int, y: int) -&gt; Optional[str]:
    &#34;&#34;&#34;Returns the text at the cell (x, y)

    Args:
        x (int): the x position of the cell
        y (int): the y position of the cell

    Returns:
        Optional[str]: the text at the cell or if no text is found, this function will return None
    &#34;&#34;&#34;
    value = self.__texts.get((x, y))
    return None if value is None else value[0].display_text</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.number_of_actors"><code class="name flex">
<span>def <span class="ident">number_of_actors</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Counts the actors existing currently in this world</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the amount of actors in the world</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number_of_actors(self) -&gt; int:
    &#34;&#34;&#34;Counts the actors existing currently in this world

    Returns:
        int: the amount of actors in the world
    &#34;&#34;&#34;
    return sum(len(actor_set) for actor_set in self.__objects.values())</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.remove_from_world"><code class="name flex">
<span>def <span class="ident">remove_from_world</span></span>(<span>self, *actors: <a title="pygreenfoot.actor.Actor" href="actor.html#pygreenfoot.actor.Actor">Actor</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the given actor(s) from the world</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_from_world(self, *actors: Actor) -&gt; None:
    &#34;&#34;&#34;
    Removes the given actor(s) from the world
    &#34;&#34;&#34;
    for actor in actors:
        actor.on_world_remove()
        self.__objects[type(actor)].remove(actor)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.repaint"><code class="name flex">
<span>def <span class="ident">repaint</span></span>(<span>self, only_background: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Redraws the whole world</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repaint(self, only_background: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Redraws the whole world
    &#34;&#34;&#34;
    if self.__background is not None:
        self.__canvas.blit(self.__background._surface, (0, 0))
    
    if only_background:
        return
    
    done: Set[Type[Actor]] = set()
    for object_type in self.__paint_order:
        done.add(object_type)
        for game_object in self.__objects[object_type]:
            game_object.repaint()
    
    for object_type in set(self.__objects) - done:
        done.add(object_type)
        for game_object in self.__objects[object_type]:
            game_object.repaint()
    
    for text, pos in self.__texts.values():
        self.__canvas.blit(text._surface, pos)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.set_act_order"><code class="name flex">
<span>def <span class="ident">set_act_order</span></span>(<span>self, *act_order: Type[<a title="pygreenfoot.actor.Actor" href="actor.html#pygreenfoot.actor.Actor">Actor</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the order in which the actor's act methods are called</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>act_order</code></strong> :&ensp;<code>Iterable</code></dt>
<dd>an iterable of types of actors to specify in which order they should be drawn.
It is not possible to influence the draw order of two actors with the same type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_act_order(self, *act_order: Type[Actor]) -&gt; None:
    &#34;&#34;&#34;Sets the order in which the actor&#39;s act methods are called

    Args:
        act_order (Iterable): an iterable of types of actors to specify in which order they should be drawn.
            It is not possible to influence the draw order of two actors with the same type.
    &#34;&#34;&#34;
    self.__act_order = list(act_order)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.set_background"><code class="name flex">
<span>def <span class="ident">set_background</span></span>(<span>self, filename_or_image: Union[str, pygame.Surface], scale_to_cell_size: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set an background image for the world. If the image is too small for the world it will be repeated in vertical
and horizontal direction until it covers all cells of the world.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename_or_image</code></strong> :&ensp;<code>Union[str, pygame.Surface]</code></dt>
<dd>a str used as path (default directory is 'images') or an pygame.Surface object</dd>
<dt><strong><code>scale_to_cell_size</code></strong> :&ensp;<code>bool</code></dt>
<dd>scales the image to the cell size if True. Default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>if the argument is a string, but an invalid filename</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background(self, filename_or_image: Union[str, pygame.Surface], scale_to_cell_size: bool = False) -&gt; None:
    &#34;&#34;&#34;Set an background image for the world. If the image is too small for the world it will be repeated in vertical 
    and horizontal direction until it covers all cells of the world.

    Args:
        filename_or_image (Union[str, pygame.Surface]): a str used as path (default directory is &#39;images&#39;) or an pygame.Surface object
        scale_to_cell_size (bool): scales the image to the cell size if True. Default is False.

    Raises:
        FileNotFoundError: if the argument is a string, but an invalid filename
    &#34;&#34;&#34;
    if isinstance(filename_or_image, str):
        path = get_resource_path(filename_or_image, &#34;image&#34;)

        image: pygame.surface.Surface = pygame.image.load(path)
        
    else:
        image: pygame.surface.Surface = filename_or_image
    
    bg = pygame.Surface((self.width * self.cell_size, self.height * self.cell_size))
    wr = range(0, self.cell_size * self.width + self.cell_size, image.get_width())
    hr = range(0, self.cell_size * self.height + self.cell_size, image.get_height())
    
    for x in wr:
        for y in hr:
            bg.blit(image.copy(), (x, y))
    
    self.__background = Image(bg)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.set_paint_order"><code class="name flex">
<span>def <span class="ident">set_paint_order</span></span>(<span>self, *paint_order: Type[<a title="pygreenfoot.actor.Actor" href="actor.html#pygreenfoot.actor.Actor">Actor</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the paint order of actor types. It is not possible to influence the draw order of two actors with the same type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paint_order</code></strong> :&ensp;<code>Iterable[Type[Actor]]</code></dt>
<dd>an iterable of types of actors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_paint_order(self, *paint_order: Type[Actor]) -&gt; None:
    &#34;&#34;&#34;Sets the paint order of actor types. It is not possible to influence the draw order of two actors with the same type

    Args:
        paint_order (Iterable[Type[Actor]]): an iterable of types of actors
    &#34;&#34;&#34;
    self.__paint_order = list(paint_order)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.world.World.show_text"><code class="name flex">
<span>def <span class="ident">show_text</span></span>(<span>self, text: Union[str, <a title="pygreenfoot.font.Text" href="font.html#pygreenfoot.font.Text">Text</a>, ForwardRef(None)], x: int, y: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the text to the cell (x, y)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>the text to be shown at cell (x, y). If the text is None it will be removed</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>the x position of the cell</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>the y position of the cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_text(self, text: Optional[Union[str, Text]], x: int, y: int) -&gt; None:
    &#34;&#34;&#34;Adds the text to the cell (x, y)

    Args:
        text (Optional[str]): the text to be shown at cell (x, y). If the text is None it will be removed
        x (int): the x position of the cell
        y (int): the y position of the cell
    &#34;&#34;&#34;
    if text is None:
        self.__texts.pop((x, y), None)
        return
    
    if isinstance(text, str):
        font = Font(Font.get_default_font(), 26)
        width, height = font._pygame.size(text)
    else:
        width, height = text.font._pygame.size(text.display_text)
        
    px: int = x * self.__cell_size + self.__half_cell - width // 2
    py: int = y * self.__cell_size + self.__half_cell - height // 2
    
    if isinstance(text, str):
        text: Text = font.get_text(text, Color(0, 0, 0), True)  # type: ignore
        
    self.__texts[(x, y)] = text, (px, py)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygreenfoot" href="index.html">pygreenfoot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygreenfoot.world.World" href="#pygreenfoot.world.World">World</a></code></h4>
<ul class="">
<li><code><a title="pygreenfoot.world.World.act" href="#pygreenfoot.world.World.act">act</a></code></li>
<li><code><a title="pygreenfoot.world.World.add_to_world" href="#pygreenfoot.world.World.add_to_world">add_to_world</a></code></li>
<li><code><a title="pygreenfoot.world.World.cell_size" href="#pygreenfoot.world.World.cell_size">cell_size</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_act_order" href="#pygreenfoot.world.World.get_act_order">get_act_order</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_actors" href="#pygreenfoot.world.World.get_actors">get_actors</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_actors_generator" href="#pygreenfoot.world.World.get_actors_generator">get_actors_generator</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_background_image" href="#pygreenfoot.world.World.get_background_image">get_background_image</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_color_at" href="#pygreenfoot.world.World.get_color_at">get_color_at</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_objects_at" href="#pygreenfoot.world.World.get_objects_at">get_objects_at</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_objects_at_generator" href="#pygreenfoot.world.World.get_objects_at_generator">get_objects_at_generator</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_paint_order" href="#pygreenfoot.world.World.get_paint_order">get_paint_order</a></code></li>
<li><code><a title="pygreenfoot.world.World.get_text_at" href="#pygreenfoot.world.World.get_text_at">get_text_at</a></code></li>
<li><code><a title="pygreenfoot.world.World.height" href="#pygreenfoot.world.World.height">height</a></code></li>
<li><code><a title="pygreenfoot.world.World.number_of_actors" href="#pygreenfoot.world.World.number_of_actors">number_of_actors</a></code></li>
<li><code><a title="pygreenfoot.world.World.remove_from_world" href="#pygreenfoot.world.World.remove_from_world">remove_from_world</a></code></li>
<li><code><a title="pygreenfoot.world.World.repaint" href="#pygreenfoot.world.World.repaint">repaint</a></code></li>
<li><code><a title="pygreenfoot.world.World.running" href="#pygreenfoot.world.World.running">running</a></code></li>
<li><code><a title="pygreenfoot.world.World.set_act_order" href="#pygreenfoot.world.World.set_act_order">set_act_order</a></code></li>
<li><code><a title="pygreenfoot.world.World.set_background" href="#pygreenfoot.world.World.set_background">set_background</a></code></li>
<li><code><a title="pygreenfoot.world.World.set_paint_order" href="#pygreenfoot.world.World.set_paint_order">set_paint_order</a></code></li>
<li><code><a title="pygreenfoot.world.World.show_text" href="#pygreenfoot.world.World.show_text">show_text</a></code></li>
<li><code><a title="pygreenfoot.world.World.width" href="#pygreenfoot.world.World.width">width</a></code></li>
<li><code><a title="pygreenfoot.world.World.world_bounding" href="#pygreenfoot.world.World.world_bounding">world_bounding</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>