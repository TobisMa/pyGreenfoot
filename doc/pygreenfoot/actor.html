<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygreenfoot.actor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygreenfoot.actor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABCMeta, abstractmethod
from math import atan2, cos, degrees, radians, sin
from typing import TYPE_CHECKING, Generator, List, Optional, Type, Union

import pygame

from pygreenfoot import get_resource_path

from .image import Image
from .math_helper import FULL_DEGREES_ANGLE, limit_value
from .__types import _ActorType

if TYPE_CHECKING:
    from .application import Application
    from .world import World

class Actor(metaclass=ABCMeta):
    
    &#34;&#34;&#34;
    Abstract base class for every object within a world (=actors).
    An object can only be added to the world as world object if it is inheriting from this class
    and overriding the `act` method
    &#34;&#34;&#34;
    
    __slots__ = (&#34;__id&#34;, &#34;__image&#34;, &#34;__pos&#34;, &#34;__rot&#34;, &#34;__size&#34;, &#34;__app&#34;)
    __game_object_count = 0
    
    def __init__(self, rotation: int = 0, image: Optional[Image] = None) -&gt; None:
        &#34;&#34;&#34;Construct an Actor. The object will have a default image.

        Args:
            rotation (int, optional): the initial rotation of the Actor. Defaults to 0.
        &#34;&#34;&#34;
        from .application import Application  # prevent circular import
        self.__id = self.__game_object_count
        Actor.__game_object_count += 1
        self.__image: Image = Image(pygame.Surface((10, 10))) if image is None else image
        self.__pos: List[int] = [0, 0]
        self.__rot = rotation % FULL_DEGREES_ANGLE
        self.__app: &#34;Application&#34; = Application.get_app()
        
    def on_world_add(self, world: &#34;World&#34;) -&gt; None:
        &#34;&#34;&#34;Called when this actor is added to a world.

        Args:
            world (World): the world this actor is added to
        &#34;&#34;&#34;
        pass
    
    def on_world_remove(self) -&gt; None:
        &#34;&#34;&#34;
        Called when this actor is removed from the world it was added to
        &#34;&#34;&#34;
        pass
    
    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Important for internal stuff&#34;&#34;&#34;
        return self.__id
    
    @abstractmethod
    def act(self) -&gt; None:
        &#34;&#34;&#34;
        Method executed once per frame when the world with this actor is currently set on the application
        This method must be implemented in subclasses.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;act method needs to be implemented in subclasses of pygreenfoot.Actor&#34;)
    
    def get_world(self) -&gt; &#34;World&#34;:
        &#34;&#34;&#34;Get the current active world

        Returns:
            World: the world which is currently active
        &#34;&#34;&#34;
        return self.__app.current_world
    
    def get_image(self) -&gt; &#34;Image&#34;:
        &#34;&#34;&#34;Return the image object of this actor

        Returns:
            Image: the current image used to draw the actor
        &#34;&#34;&#34;
        return self.__image
    
    def set_image(self, filename_or_image: Union[str, &#34;Image&#34;]) -&gt; None:  # type: ignore
        &#34;&#34;&#34;Set the image of the actor

        Args:
            filename_or_image (Union[str, pygame.surface.Surface]): a string to the image file or an
                Surfaces object from pygame. For files is first looked in the `imageResourceFolder` 
                which defaults to `images` and secondly in the packages own image folder

        Raises:
            FileNotFoundError: if the given argument is a string, but no resource was found
        &#34;&#34;&#34;
        file_or_surf: Union[str, pygame.surface.Surface] = filename_or_image if isinstance(filename_or_image, str) else filename_or_image._surface  # type: ignore
        if isinstance(file_or_surf, str):
            path = get_resource_path(file_or_surf, &#34;image&#34;)
            file_or_surf: pygame.surface.Surface = pygame.image.load(path)
        
        else:
            file_or_surf = pygame.Surface((self.x, self.y), surface=file_or_surf)
        
        file_or_surf = pygame.transform.rotate(file_or_surf, self.rotation)
        image = Image(file_or_surf)
        self.__image = image
        
    @property
    def x(self) -&gt; int:
        &#34;&#34;&#34;
        x-coordinate of the object using transform
        &#34;&#34;&#34;
        self.__check_boundary()
        return self.__pos[0]
    
    @x.setter
    def x(self, value: int) -&gt; None:
        self.__pos[0] = value
        self.__check_boundary()
    
    @property
    def y(self) -&gt; int:
        &#34;&#34;&#34;
        y-coordinate of the object using transform
        &#34;&#34;&#34;
        self.__check_boundary()
        return self.__pos[1]
    
    @y.setter
    def y(self, value: int) -&gt; None:
        self.__pos[1] = value
        self.__check_boundary()
        
        
    def __check_boundary(self) -&gt; None:
        &#34;&#34;&#34;
        Sets the actor back into the world if world bounding is set to True
        &#34;&#34;&#34;
        try:
            world = self.get_world()
        except ValueError:
            return
        
        if world.world_bounding:
            self.__pos[0] = limit_value(self.__pos[0], 0, world.width - 1)
            self.__pos[1] = limit_value(self.__pos[1], 0, world.height - 1)
        
    @property
    def rotation(self) -&gt; float:
        &#34;&#34;&#34;
        the rotation of the actor in degrees
        &#34;&#34;&#34;
        return self.__rot

    @rotation.setter
    def rotation(self, value: float) -&gt; None:
        self.__rot = value % FULL_DEGREES_ANGLE
        if self.__image is not None:
            self.__image._set_rot(self.__rot)
        
    def repaint(self) -&gt; None:
        &#34;&#34;&#34;
        draws the actor anew in the world
        &#34;&#34;&#34;
        self.__check_boundary()
        world = self.get_world()
        if self.get_image() is not None:
            rel_pos = self.get_image()._rel_pos
            pos = [
                self.x * world.cell_size + max(0, (world.cell_size - self.get_image().width)) / 2 + rel_pos[0] / 2,
                self.y * world.cell_size + max(0, (world.cell_size - self.get_image().height)) / 2 + rel_pos[1] / 2
                
            ]
            screen = world._surface
            screen.blit(self.get_image()._surface, pos)
    
    @property
    def _rect(self) -&gt; pygame.Rect:
        &#34;&#34;&#34;
        A pygame.Rect object representing this objects boundaries
        &#34;&#34;&#34;
        world = self.get_world()
        return pygame.Rect(self.x * world.cell_size, self.y * world.cell_size, self.__image.width, self.__image.height)
    
    
    def get_intersecting_actors(self, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
        &#34;&#34;&#34;this method returns the same as `get_intersecting_actors_generator` as a list. 
        This method has to be used if actors are getting removed during iteration.
        
        Returns:
            type_: all the intersecting actors of type type_
        &#34;&#34;&#34;
        return list(self.get_intersecting_actors_generator(type_))

    def get_intersecting_actors_generator(self, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns a generator object to iterate over all actors intersecting this one.
        The rectangular representation of the actors will be used for collision detection 

        Yields:
            Actor: an intersecting actor of type type_
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            if a._rect.colliderect(self._rect):
                yield a
    
    def get_actors_in_range(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Returns a list of all actors within range of this one of type type_. None is treated as wildcard&#34;&#34;&#34;
        return list(self.get_actors_in_range_generator(radius, type_))
        
    def get_actors_in_range_generator(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;A generator iterating over all actors of type type_ within radius. None is treated as wildcard

        Yields:
            Actor: all actors of type type_ within radius
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            dx = a.x - self.x
            dx *= dx
            dy = a.y - self.y
            dy *= dy
            if dx + dy &lt;= radius ** 2:
                yield a
    
    def get_actors_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
        &#34;&#34;&#34;
        Returns the same as get_actors_at_offset_generator but converted to a list
        &#34;&#34;&#34;
        return list(self.get_actors_at_offset_generator(dx, dy, type_))
    
    def get_one_actor_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Optional[_ActorType]:
        &#34;&#34;&#34;
        Returns the first found actor of type_ at the current location + the given offset

        Returns:
            Optional[Actor]: None if no actor has been found otherwise the Actor
        &#34;&#34;&#34;
        try:
            return next(self.get_actors_at_offset_generator(dx, dy, type_))
        except StopIteration:
            return None
    
    def get_actors_at_offset_generator(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns all objects at the relative offset (dx, dy) of this actor&#39;s coordinates.

        Yields:
            Actor: an actor which is at that relative offset
        &#34;&#34;&#34;
        yield from self.get_world().get_objects_at_generator(self.x + dx, self.y + dy, type_)
    
    def get_neighbours(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Returns the same as get_neighbours_generator but as a list instead of a generator object

        Returns:
            List[Actor]: all actors considered as neighbours
        &#34;&#34;&#34;
        return list(self.get_neighbours_generator(cells, diagonal, type_))
    
    def get_neighbours_generator(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns all actors considered to be neighbours. if diagonal=True it will be the same as get_actors_in_range(cells, type_)
        if diagonal is False it will consider an actor as neighbours if either x or y have the same value and the absolute difference between
        x or y is less than or equals the specified cells

        Yields:
            Actor: actors considered to be neighbours
        &#34;&#34;&#34;
        if diagonal:
            yield from self.get_actors_in_range(cells * self.get_world().cell_size, type_)
        else:
            actors = self.get_world().get_actors(type_)
            for a in actors:
                if abs(a.x - self.x) &lt;= cells or abs(a.y - self.y) &lt;= cells:
                    yield a
    
    def is_at_edge(self) -&gt; bool:
        &#34;&#34;&#34;if the actor is at the edge of the world.

        Returns:
            bool: True if the actor is outside of the world or on the last row/column within th world
        &#34;&#34;&#34;
        world = self.get_world()
        return not world._rect.contains(self._rect) or self.x == 0 or self.y == 0 or self.x == world.width - 1 or self.y == world.height - 1
    
    def intersects(self, actor: &#34;Actor&#34;) -&gt; bool:
        &#34;&#34;&#34;Checks for graphical intersection between two actors. Rotation is not considered

        Args:
            actor (Actor): the other actor

        Returns:
            bool: True if the actors intersect each other, False otherwise.
        &#34;&#34;&#34;
        return bool(actor._rect.colliderect(self._rect))
    
    def is_touching(self, type_: Type[&#34;Actor&#34;]) -&gt; bool:
        &#34;&#34;&#34;Checks if the actor touches an actor of given type type_

        Args:
            type_ (Type[Actor]): the type of the other actor

        Returns:
            bool: True if at least one actor of the given type_ was found.
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            if a == self:
                continue
            elif self.intersects(a):
                return True
        return False
    
    def remove_touching(self, type_: Type[&#34;Actor&#34;], fail_silently: bool = False) -&gt; None:
        &#34;&#34;&#34;Removes the first found actor of type type_ which is being touched by this actor

        Args:
            type_ (Type[Actor): the type the other actor shall have
            fail_silently (bool, optional): If set to True, no error will be raised in case no actor of type_ is touched. Defaults to False.

        Raises:
            RuntimeError: _description_
        &#34;&#34;&#34;
        world = self.get_world()
        actors = world.get_actors_generator(type_)
        remove = None
        for a in actors:
            if a == self:
                continue
            elif self.intersects(a):
                remove = a
                break
        
        if remove is not None:
            world.remove_from_world(remove)
        elif not fail_silently:
            raise RuntimeError(&#34;Not touching an actor of type %s&#34; % type_.__name__)
        
    def turn_towards(self, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Turns the actor towards the given coordinates

        Args:
            x (int): x coordinate of the direction
            y (int): y coordinate of the direction
        &#34;&#34;&#34;
        self.rotation = degrees(atan2(y - self.y, x - self.x))
        
    def set_position(self, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Sets the position of the actor to (x, y)

        Args:
            x (int): the new x coordinate
            y (int): the new y coordinate
        &#34;&#34;&#34;
        self.__pos = [x, y]
        self.__check_boundary()
    
    def move(self, steps: int = 1) -&gt; None:
        &#34;&#34;&#34;Move into the direction the actor is currently facing

        Args:
            steps (int, optional): the amount of cells the actor shall go. In case of a rotation like 30° the steps will be rounded. Defaults to 1.
        &#34;&#34;&#34;
        self.x += round(steps * cos(radians(self.rotation)))
        self.y += round(steps * sin(radians(self.rotation)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygreenfoot.actor.Actor"><code class="flex name class">
<span>class <span class="ident">Actor</span></span>
<span>(</span><span>rotation: int = 0, image: Optional[<a title="pygreenfoot.image.Image" href="image.html#pygreenfoot.image.Image">Image</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for every object within a world (=actors).
An object can only be added to the world as world object if it is inheriting from this class
and overriding the <code>act</code> method</p>
<p>Construct an Actor. The object will have a default image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rotation</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the initial rotation of the Actor. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Actor(metaclass=ABCMeta):
    
    &#34;&#34;&#34;
    Abstract base class for every object within a world (=actors).
    An object can only be added to the world as world object if it is inheriting from this class
    and overriding the `act` method
    &#34;&#34;&#34;
    
    __slots__ = (&#34;__id&#34;, &#34;__image&#34;, &#34;__pos&#34;, &#34;__rot&#34;, &#34;__size&#34;, &#34;__app&#34;)
    __game_object_count = 0
    
    def __init__(self, rotation: int = 0, image: Optional[Image] = None) -&gt; None:
        &#34;&#34;&#34;Construct an Actor. The object will have a default image.

        Args:
            rotation (int, optional): the initial rotation of the Actor. Defaults to 0.
        &#34;&#34;&#34;
        from .application import Application  # prevent circular import
        self.__id = self.__game_object_count
        Actor.__game_object_count += 1
        self.__image: Image = Image(pygame.Surface((10, 10))) if image is None else image
        self.__pos: List[int] = [0, 0]
        self.__rot = rotation % FULL_DEGREES_ANGLE
        self.__app: &#34;Application&#34; = Application.get_app()
        
    def on_world_add(self, world: &#34;World&#34;) -&gt; None:
        &#34;&#34;&#34;Called when this actor is added to a world.

        Args:
            world (World): the world this actor is added to
        &#34;&#34;&#34;
        pass
    
    def on_world_remove(self) -&gt; None:
        &#34;&#34;&#34;
        Called when this actor is removed from the world it was added to
        &#34;&#34;&#34;
        pass
    
    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Important for internal stuff&#34;&#34;&#34;
        return self.__id
    
    @abstractmethod
    def act(self) -&gt; None:
        &#34;&#34;&#34;
        Method executed once per frame when the world with this actor is currently set on the application
        This method must be implemented in subclasses.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;act method needs to be implemented in subclasses of pygreenfoot.Actor&#34;)
    
    def get_world(self) -&gt; &#34;World&#34;:
        &#34;&#34;&#34;Get the current active world

        Returns:
            World: the world which is currently active
        &#34;&#34;&#34;
        return self.__app.current_world
    
    def get_image(self) -&gt; &#34;Image&#34;:
        &#34;&#34;&#34;Return the image object of this actor

        Returns:
            Image: the current image used to draw the actor
        &#34;&#34;&#34;
        return self.__image
    
    def set_image(self, filename_or_image: Union[str, &#34;Image&#34;]) -&gt; None:  # type: ignore
        &#34;&#34;&#34;Set the image of the actor

        Args:
            filename_or_image (Union[str, pygame.surface.Surface]): a string to the image file or an
                Surfaces object from pygame. For files is first looked in the `imageResourceFolder` 
                which defaults to `images` and secondly in the packages own image folder

        Raises:
            FileNotFoundError: if the given argument is a string, but no resource was found
        &#34;&#34;&#34;
        file_or_surf: Union[str, pygame.surface.Surface] = filename_or_image if isinstance(filename_or_image, str) else filename_or_image._surface  # type: ignore
        if isinstance(file_or_surf, str):
            path = get_resource_path(file_or_surf, &#34;image&#34;)
            file_or_surf: pygame.surface.Surface = pygame.image.load(path)
        
        else:
            file_or_surf = pygame.Surface((self.x, self.y), surface=file_or_surf)
        
        file_or_surf = pygame.transform.rotate(file_or_surf, self.rotation)
        image = Image(file_or_surf)
        self.__image = image
        
    @property
    def x(self) -&gt; int:
        &#34;&#34;&#34;
        x-coordinate of the object using transform
        &#34;&#34;&#34;
        self.__check_boundary()
        return self.__pos[0]
    
    @x.setter
    def x(self, value: int) -&gt; None:
        self.__pos[0] = value
        self.__check_boundary()
    
    @property
    def y(self) -&gt; int:
        &#34;&#34;&#34;
        y-coordinate of the object using transform
        &#34;&#34;&#34;
        self.__check_boundary()
        return self.__pos[1]
    
    @y.setter
    def y(self, value: int) -&gt; None:
        self.__pos[1] = value
        self.__check_boundary()
        
        
    def __check_boundary(self) -&gt; None:
        &#34;&#34;&#34;
        Sets the actor back into the world if world bounding is set to True
        &#34;&#34;&#34;
        try:
            world = self.get_world()
        except ValueError:
            return
        
        if world.world_bounding:
            self.__pos[0] = limit_value(self.__pos[0], 0, world.width - 1)
            self.__pos[1] = limit_value(self.__pos[1], 0, world.height - 1)
        
    @property
    def rotation(self) -&gt; float:
        &#34;&#34;&#34;
        the rotation of the actor in degrees
        &#34;&#34;&#34;
        return self.__rot

    @rotation.setter
    def rotation(self, value: float) -&gt; None:
        self.__rot = value % FULL_DEGREES_ANGLE
        if self.__image is not None:
            self.__image._set_rot(self.__rot)
        
    def repaint(self) -&gt; None:
        &#34;&#34;&#34;
        draws the actor anew in the world
        &#34;&#34;&#34;
        self.__check_boundary()
        world = self.get_world()
        if self.get_image() is not None:
            rel_pos = self.get_image()._rel_pos
            pos = [
                self.x * world.cell_size + max(0, (world.cell_size - self.get_image().width)) / 2 + rel_pos[0] / 2,
                self.y * world.cell_size + max(0, (world.cell_size - self.get_image().height)) / 2 + rel_pos[1] / 2
                
            ]
            screen = world._surface
            screen.blit(self.get_image()._surface, pos)
    
    @property
    def _rect(self) -&gt; pygame.Rect:
        &#34;&#34;&#34;
        A pygame.Rect object representing this objects boundaries
        &#34;&#34;&#34;
        world = self.get_world()
        return pygame.Rect(self.x * world.cell_size, self.y * world.cell_size, self.__image.width, self.__image.height)
    
    
    def get_intersecting_actors(self, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
        &#34;&#34;&#34;this method returns the same as `get_intersecting_actors_generator` as a list. 
        This method has to be used if actors are getting removed during iteration.
        
        Returns:
            type_: all the intersecting actors of type type_
        &#34;&#34;&#34;
        return list(self.get_intersecting_actors_generator(type_))

    def get_intersecting_actors_generator(self, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns a generator object to iterate over all actors intersecting this one.
        The rectangular representation of the actors will be used for collision detection 

        Yields:
            Actor: an intersecting actor of type type_
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            if a._rect.colliderect(self._rect):
                yield a
    
    def get_actors_in_range(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Returns a list of all actors within range of this one of type type_. None is treated as wildcard&#34;&#34;&#34;
        return list(self.get_actors_in_range_generator(radius, type_))
        
    def get_actors_in_range_generator(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;A generator iterating over all actors of type type_ within radius. None is treated as wildcard

        Yields:
            Actor: all actors of type type_ within radius
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            dx = a.x - self.x
            dx *= dx
            dy = a.y - self.y
            dy *= dy
            if dx + dy &lt;= radius ** 2:
                yield a
    
    def get_actors_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
        &#34;&#34;&#34;
        Returns the same as get_actors_at_offset_generator but converted to a list
        &#34;&#34;&#34;
        return list(self.get_actors_at_offset_generator(dx, dy, type_))
    
    def get_one_actor_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Optional[_ActorType]:
        &#34;&#34;&#34;
        Returns the first found actor of type_ at the current location + the given offset

        Returns:
            Optional[Actor]: None if no actor has been found otherwise the Actor
        &#34;&#34;&#34;
        try:
            return next(self.get_actors_at_offset_generator(dx, dy, type_))
        except StopIteration:
            return None
    
    def get_actors_at_offset_generator(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns all objects at the relative offset (dx, dy) of this actor&#39;s coordinates.

        Yields:
            Actor: an actor which is at that relative offset
        &#34;&#34;&#34;
        yield from self.get_world().get_objects_at_generator(self.x + dx, self.y + dy, type_)
    
    def get_neighbours(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
        &#34;&#34;&#34;Returns the same as get_neighbours_generator but as a list instead of a generator object

        Returns:
            List[Actor]: all actors considered as neighbours
        &#34;&#34;&#34;
        return list(self.get_neighbours_generator(cells, diagonal, type_))
    
    def get_neighbours_generator(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
        &#34;&#34;&#34;Returns all actors considered to be neighbours. if diagonal=True it will be the same as get_actors_in_range(cells, type_)
        if diagonal is False it will consider an actor as neighbours if either x or y have the same value and the absolute difference between
        x or y is less than or equals the specified cells

        Yields:
            Actor: actors considered to be neighbours
        &#34;&#34;&#34;
        if diagonal:
            yield from self.get_actors_in_range(cells * self.get_world().cell_size, type_)
        else:
            actors = self.get_world().get_actors(type_)
            for a in actors:
                if abs(a.x - self.x) &lt;= cells or abs(a.y - self.y) &lt;= cells:
                    yield a
    
    def is_at_edge(self) -&gt; bool:
        &#34;&#34;&#34;if the actor is at the edge of the world.

        Returns:
            bool: True if the actor is outside of the world or on the last row/column within th world
        &#34;&#34;&#34;
        world = self.get_world()
        return not world._rect.contains(self._rect) or self.x == 0 or self.y == 0 or self.x == world.width - 1 or self.y == world.height - 1
    
    def intersects(self, actor: &#34;Actor&#34;) -&gt; bool:
        &#34;&#34;&#34;Checks for graphical intersection between two actors. Rotation is not considered

        Args:
            actor (Actor): the other actor

        Returns:
            bool: True if the actors intersect each other, False otherwise.
        &#34;&#34;&#34;
        return bool(actor._rect.colliderect(self._rect))
    
    def is_touching(self, type_: Type[&#34;Actor&#34;]) -&gt; bool:
        &#34;&#34;&#34;Checks if the actor touches an actor of given type type_

        Args:
            type_ (Type[Actor]): the type of the other actor

        Returns:
            bool: True if at least one actor of the given type_ was found.
        &#34;&#34;&#34;
        actors = self.get_world().get_actors_generator(type_)
        for a in actors:
            if a == self:
                continue
            elif self.intersects(a):
                return True
        return False
    
    def remove_touching(self, type_: Type[&#34;Actor&#34;], fail_silently: bool = False) -&gt; None:
        &#34;&#34;&#34;Removes the first found actor of type type_ which is being touched by this actor

        Args:
            type_ (Type[Actor): the type the other actor shall have
            fail_silently (bool, optional): If set to True, no error will be raised in case no actor of type_ is touched. Defaults to False.

        Raises:
            RuntimeError: _description_
        &#34;&#34;&#34;
        world = self.get_world()
        actors = world.get_actors_generator(type_)
        remove = None
        for a in actors:
            if a == self:
                continue
            elif self.intersects(a):
                remove = a
                break
        
        if remove is not None:
            world.remove_from_world(remove)
        elif not fail_silently:
            raise RuntimeError(&#34;Not touching an actor of type %s&#34; % type_.__name__)
        
    def turn_towards(self, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Turns the actor towards the given coordinates

        Args:
            x (int): x coordinate of the direction
            y (int): y coordinate of the direction
        &#34;&#34;&#34;
        self.rotation = degrees(atan2(y - self.y, x - self.x))
        
    def set_position(self, x: int, y: int) -&gt; None:
        &#34;&#34;&#34;Sets the position of the actor to (x, y)

        Args:
            x (int): the new x coordinate
            y (int): the new y coordinate
        &#34;&#34;&#34;
        self.__pos = [x, y]
        self.__check_boundary()
    
    def move(self, steps: int = 1) -&gt; None:
        &#34;&#34;&#34;Move into the direction the actor is currently facing

        Args:
            steps (int, optional): the amount of cells the actor shall go. In case of a rotation like 30° the steps will be rounded. Defaults to 1.
        &#34;&#34;&#34;
        self.x += round(steps * cos(radians(self.rotation)))
        self.y += round(steps * sin(radians(self.rotation)))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pygreenfoot.templates.counter.Counter" href="templates/counter.html#pygreenfoot.templates.counter.Counter">Counter</a></li>
<li><a title="pygreenfoot.templates.init_actor.InitActor" href="templates/init_actor.html#pygreenfoot.templates.init_actor.InitActor">InitActor</a></li>
<li><a title="pygreenfoot.templates.label.Label" href="templates/label.html#pygreenfoot.templates.label.Label">Label</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygreenfoot.actor.Actor.rotation"><code class="name">var <span class="ident">rotation</span> : float</code></dt>
<dd>
<div class="desc"><p>the rotation of the actor in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation(self) -&gt; float:
    &#34;&#34;&#34;
    the rotation of the actor in degrees
    &#34;&#34;&#34;
    return self.__rot</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.x"><code class="name">var <span class="ident">x</span> : int</code></dt>
<dd>
<div class="desc"><p>x-coordinate of the object using transform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self) -&gt; int:
    &#34;&#34;&#34;
    x-coordinate of the object using transform
    &#34;&#34;&#34;
    self.__check_boundary()
    return self.__pos[0]</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.y"><code class="name">var <span class="ident">y</span> : int</code></dt>
<dd>
<div class="desc"><p>y-coordinate of the object using transform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self) -&gt; int:
    &#34;&#34;&#34;
    y-coordinate of the object using transform
    &#34;&#34;&#34;
    self.__check_boundary()
    return self.__pos[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygreenfoot.actor.Actor.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Method executed once per frame when the world with this actor is currently set on the application
This method must be implemented in subclasses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def act(self) -&gt; None:
    &#34;&#34;&#34;
    Method executed once per frame when the world with this actor is currently set on the application
    This method must be implemented in subclasses.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;act method needs to be implemented in subclasses of pygreenfoot.Actor&#34;)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_actors_at_offset"><code class="name flex">
<span>def <span class="ident">get_actors_at_offset</span></span>(<span>self, dx: int, dy: int, type_: Optional[Type[~_ActorType]]) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the same as get_actors_at_offset_generator but converted to a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
    &#34;&#34;&#34;
    Returns the same as get_actors_at_offset_generator but converted to a list
    &#34;&#34;&#34;
    return list(self.get_actors_at_offset_generator(dx, dy, type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_actors_at_offset_generator"><code class="name flex">
<span>def <span class="ident">get_actors_at_offset_generator</span></span>(<span>self, dx: int, dy: int, type_: Optional[Type[~_ActorType]]) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all objects at the relative offset (dx, dy) of this actor's coordinates.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>an actor which is at that relative offset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors_at_offset_generator(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
    &#34;&#34;&#34;Returns all objects at the relative offset (dx, dy) of this actor&#39;s coordinates.

    Yields:
        Actor: an actor which is at that relative offset
    &#34;&#34;&#34;
    yield from self.get_world().get_objects_at_generator(self.x + dx, self.y + dy, type_)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_actors_in_range"><code class="name flex">
<span>def <span class="ident">get_actors_in_range</span></span>(<span>self, radius: int, type_: Optional[Type[~_ActorType]] = None) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all actors within range of this one of type type_. None is treated as wildcard</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors_in_range(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
    &#34;&#34;&#34;Returns a list of all actors within range of this one of type type_. None is treated as wildcard&#34;&#34;&#34;
    return list(self.get_actors_in_range_generator(radius, type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_actors_in_range_generator"><code class="name flex">
<span>def <span class="ident">get_actors_in_range_generator</span></span>(<span>self, radius: int, type_: Optional[Type[~_ActorType]] = None) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>A generator iterating over all actors of type type_ within radius. None is treated as wildcard</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>all actors of type type_ within radius</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actors_in_range_generator(self, radius: int, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
    &#34;&#34;&#34;A generator iterating over all actors of type type_ within radius. None is treated as wildcard

    Yields:
        Actor: all actors of type type_ within radius
    &#34;&#34;&#34;
    actors = self.get_world().get_actors_generator(type_)
    for a in actors:
        dx = a.x - self.x
        dx *= dx
        dy = a.y - self.y
        dy *= dy
        if dx + dy &lt;= radius ** 2:
            yield a</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self) ‑> <a title="pygreenfoot.image.Image" href="image.html#pygreenfoot.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the image object of this actor</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Image</code></dt>
<dd>the current image used to draw the actor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self) -&gt; &#34;Image&#34;:
    &#34;&#34;&#34;Return the image object of this actor

    Returns:
        Image: the current image used to draw the actor
    &#34;&#34;&#34;
    return self.__image</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_intersecting_actors"><code class="name flex">
<span>def <span class="ident">get_intersecting_actors</span></span>(<span>self, type_: Optional[Type[~_ActorType]]) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>this method returns the same as <code>get_intersecting_actors_generator</code> as a list.
This method has to be used if actors are getting removed during iteration.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>type_</code></dt>
<dd>all the intersecting actors of type type_</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intersecting_actors(self, type_: Optional[Type[_ActorType]]) -&gt; List[_ActorType]:
    &#34;&#34;&#34;this method returns the same as `get_intersecting_actors_generator` as a list. 
    This method has to be used if actors are getting removed during iteration.
    
    Returns:
        type_: all the intersecting actors of type type_
    &#34;&#34;&#34;
    return list(self.get_intersecting_actors_generator(type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_intersecting_actors_generator"><code class="name flex">
<span>def <span class="ident">get_intersecting_actors_generator</span></span>(<span>self, type_: Optional[Type[~_ActorType]]) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator object to iterate over all actors intersecting this one.
The rectangular representation of the actors will be used for collision detection </p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>an intersecting actor of type type_</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intersecting_actors_generator(self, type_: Optional[Type[_ActorType]]) -&gt; Generator[_ActorType, None, None]:
    &#34;&#34;&#34;Returns a generator object to iterate over all actors intersecting this one.
    The rectangular representation of the actors will be used for collision detection 

    Yields:
        Actor: an intersecting actor of type type_
    &#34;&#34;&#34;
    actors = self.get_world().get_actors_generator(type_)
    for a in actors:
        if a._rect.colliderect(self._rect):
            yield a</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_neighbours"><code class="name flex">
<span>def <span class="ident">get_neighbours</span></span>(<span>self, cells: int, diagonal: bool = False, type_: Optional[Type[~_ActorType]] = None) ‑> List[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the same as get_neighbours_generator but as a list instead of a generator object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>]</code></dt>
<dd>all actors considered as neighbours</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbours(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; List[_ActorType]:
    &#34;&#34;&#34;Returns the same as get_neighbours_generator but as a list instead of a generator object

    Returns:
        List[Actor]: all actors considered as neighbours
    &#34;&#34;&#34;
    return list(self.get_neighbours_generator(cells, diagonal, type_))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_neighbours_generator"><code class="name flex">
<span>def <span class="ident">get_neighbours_generator</span></span>(<span>self, cells: int, diagonal: bool = False, type_: Optional[Type[~_ActorType]] = None) ‑> Generator[~_ActorType, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all actors considered to be neighbours. if diagonal=True it will be the same as get_actors_in_range(cells, type_)
if diagonal is False it will consider an actor as neighbours if either x or y have the same value and the absolute difference between
x or y is less than or equals the specified cells</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>actors considered to be neighbours</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbours_generator(self, cells: int, diagonal: bool = False, type_: Optional[Type[_ActorType]] = None) -&gt; Generator[_ActorType, None, None]:
    &#34;&#34;&#34;Returns all actors considered to be neighbours. if diagonal=True it will be the same as get_actors_in_range(cells, type_)
    if diagonal is False it will consider an actor as neighbours if either x or y have the same value and the absolute difference between
    x or y is less than or equals the specified cells

    Yields:
        Actor: actors considered to be neighbours
    &#34;&#34;&#34;
    if diagonal:
        yield from self.get_actors_in_range(cells * self.get_world().cell_size, type_)
    else:
        actors = self.get_world().get_actors(type_)
        for a in actors:
            if abs(a.x - self.x) &lt;= cells or abs(a.y - self.y) &lt;= cells:
                yield a</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_one_actor_at_offset"><code class="name flex">
<span>def <span class="ident">get_one_actor_at_offset</span></span>(<span>self, dx: int, dy: int, type_: Optional[Type[~_ActorType]]) ‑> Optional[~_ActorType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first found actor of type_ at the current location + the given offset</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>]</code></dt>
<dd>None if no actor has been found otherwise the Actor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_one_actor_at_offset(self, dx: int, dy: int, type_: Optional[Type[_ActorType]]) -&gt; Optional[_ActorType]:
    &#34;&#34;&#34;
    Returns the first found actor of type_ at the current location + the given offset

    Returns:
        Optional[Actor]: None if no actor has been found otherwise the Actor
    &#34;&#34;&#34;
    try:
        return next(self.get_actors_at_offset_generator(dx, dy, type_))
    except StopIteration:
        return None</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.get_world"><code class="name flex">
<span>def <span class="ident">get_world</span></span>(<span>self) ‑> World</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current active world</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>World</code></dt>
<dd>the world which is currently active</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_world(self) -&gt; &#34;World&#34;:
    &#34;&#34;&#34;Get the current active world

    Returns:
        World: the world which is currently active
    &#34;&#34;&#34;
    return self.__app.current_world</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.intersects"><code class="name flex">
<span>def <span class="ident">intersects</span></span>(<span>self, actor: <a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for graphical intersection between two actors. Rotation is not considered</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>actor</code></strong> :&ensp;<code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>the other actor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the actors intersect each other, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersects(self, actor: &#34;Actor&#34;) -&gt; bool:
    &#34;&#34;&#34;Checks for graphical intersection between two actors. Rotation is not considered

    Args:
        actor (Actor): the other actor

    Returns:
        bool: True if the actors intersect each other, False otherwise.
    &#34;&#34;&#34;
    return bool(actor._rect.colliderect(self._rect))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.is_at_edge"><code class="name flex">
<span>def <span class="ident">is_at_edge</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>if the actor is at the edge of the world.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the actor is outside of the world or on the last row/column within th world</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_at_edge(self) -&gt; bool:
    &#34;&#34;&#34;if the actor is at the edge of the world.

    Returns:
        bool: True if the actor is outside of the world or on the last row/column within th world
    &#34;&#34;&#34;
    world = self.get_world()
    return not world._rect.contains(self._rect) or self.x == 0 or self.y == 0 or self.x == world.width - 1 or self.y == world.height - 1</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.is_touching"><code class="name flex">
<span>def <span class="ident">is_touching</span></span>(<span>self, type_: Type[ForwardRef('<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>')]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the actor touches an actor of given type type_</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_</code></strong> :&ensp;<code>Type[<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>]</code></dt>
<dd>the type of the other actor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if at least one actor of the given type_ was found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_touching(self, type_: Type[&#34;Actor&#34;]) -&gt; bool:
    &#34;&#34;&#34;Checks if the actor touches an actor of given type type_

    Args:
        type_ (Type[Actor]): the type of the other actor

    Returns:
        bool: True if at least one actor of the given type_ was found.
    &#34;&#34;&#34;
    actors = self.get_world().get_actors_generator(type_)
    for a in actors:
        if a == self:
            continue
        elif self.intersects(a):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, steps: int = 1) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Move into the direction the actor is currently facing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the amount of cells the actor shall go. In case of a rotation like 30° the steps will be rounded. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, steps: int = 1) -&gt; None:
    &#34;&#34;&#34;Move into the direction the actor is currently facing

    Args:
        steps (int, optional): the amount of cells the actor shall go. In case of a rotation like 30° the steps will be rounded. Defaults to 1.
    &#34;&#34;&#34;
    self.x += round(steps * cos(radians(self.rotation)))
    self.y += round(steps * sin(radians(self.rotation)))</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.on_world_add"><code class="name flex">
<span>def <span class="ident">on_world_add</span></span>(<span>self, world: World)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when this actor is added to a world.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>world</code></strong> :&ensp;<code>World</code></dt>
<dd>the world this actor is added to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_world_add(self, world: &#34;World&#34;) -&gt; None:
    &#34;&#34;&#34;Called when this actor is added to a world.

    Args:
        world (World): the world this actor is added to
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.on_world_remove"><code class="name flex">
<span>def <span class="ident">on_world_remove</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called when this actor is removed from the world it was added to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_world_remove(self) -&gt; None:
    &#34;&#34;&#34;
    Called when this actor is removed from the world it was added to
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.remove_touching"><code class="name flex">
<span>def <span class="ident">remove_touching</span></span>(<span>self, type_: Type[ForwardRef('<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a>')], fail_silently: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the first found actor of type type_ which is being touched by this actor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_</code></strong> :&ensp;<code>Type[<a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></dt>
<dd>the type the other actor shall have</dd>
<dt><strong><code>fail_silently</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If set to True, no error will be raised in case no actor of type_ is touched. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_touching(self, type_: Type[&#34;Actor&#34;], fail_silently: bool = False) -&gt; None:
    &#34;&#34;&#34;Removes the first found actor of type type_ which is being touched by this actor

    Args:
        type_ (Type[Actor): the type the other actor shall have
        fail_silently (bool, optional): If set to True, no error will be raised in case no actor of type_ is touched. Defaults to False.

    Raises:
        RuntimeError: _description_
    &#34;&#34;&#34;
    world = self.get_world()
    actors = world.get_actors_generator(type_)
    remove = None
    for a in actors:
        if a == self:
            continue
        elif self.intersects(a):
            remove = a
            break
    
    if remove is not None:
        world.remove_from_world(remove)
    elif not fail_silently:
        raise RuntimeError(&#34;Not touching an actor of type %s&#34; % type_.__name__)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.repaint"><code class="name flex">
<span>def <span class="ident">repaint</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>draws the actor anew in the world</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repaint(self) -&gt; None:
    &#34;&#34;&#34;
    draws the actor anew in the world
    &#34;&#34;&#34;
    self.__check_boundary()
    world = self.get_world()
    if self.get_image() is not None:
        rel_pos = self.get_image()._rel_pos
        pos = [
            self.x * world.cell_size + max(0, (world.cell_size - self.get_image().width)) / 2 + rel_pos[0] / 2,
            self.y * world.cell_size + max(0, (world.cell_size - self.get_image().height)) / 2 + rel_pos[1] / 2
            
        ]
        screen = world._surface
        screen.blit(self.get_image()._surface, pos)</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, filename_or_image: Union[str, ForwardRef('Image')]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the image of the actor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename_or_image</code></strong> :&ensp;<code>Union[str, pygame.surface.Surface]</code></dt>
<dd>a string to the image file or an
Surfaces object from pygame. For files is first looked in the <code>imageResourceFolder</code>
which defaults to <code>images</code> and secondly in the packages own image folder</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>if the given argument is a string, but no resource was found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, filename_or_image: Union[str, &#34;Image&#34;]) -&gt; None:  # type: ignore
    &#34;&#34;&#34;Set the image of the actor

    Args:
        filename_or_image (Union[str, pygame.surface.Surface]): a string to the image file or an
            Surfaces object from pygame. For files is first looked in the `imageResourceFolder` 
            which defaults to `images` and secondly in the packages own image folder

    Raises:
        FileNotFoundError: if the given argument is a string, but no resource was found
    &#34;&#34;&#34;
    file_or_surf: Union[str, pygame.surface.Surface] = filename_or_image if isinstance(filename_or_image, str) else filename_or_image._surface  # type: ignore
    if isinstance(file_or_surf, str):
        path = get_resource_path(file_or_surf, &#34;image&#34;)
        file_or_surf: pygame.surface.Surface = pygame.image.load(path)
    
    else:
        file_or_surf = pygame.Surface((self.x, self.y), surface=file_or_surf)
    
    file_or_surf = pygame.transform.rotate(file_or_surf, self.rotation)
    image = Image(file_or_surf)
    self.__image = image</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.set_position"><code class="name flex">
<span>def <span class="ident">set_position</span></span>(<span>self, x: int, y: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the position of the actor to (x, y)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>the new x coordinate</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>the new y coordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_position(self, x: int, y: int) -&gt; None:
    &#34;&#34;&#34;Sets the position of the actor to (x, y)

    Args:
        x (int): the new x coordinate
        y (int): the new y coordinate
    &#34;&#34;&#34;
    self.__pos = [x, y]
    self.__check_boundary()</code></pre>
</details>
</dd>
<dt id="pygreenfoot.actor.Actor.turn_towards"><code class="name flex">
<span>def <span class="ident">turn_towards</span></span>(<span>self, x: int, y: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the actor towards the given coordinates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>x coordinate of the direction</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>y coordinate of the direction</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_towards(self, x: int, y: int) -&gt; None:
    &#34;&#34;&#34;Turns the actor towards the given coordinates

    Args:
        x (int): x coordinate of the direction
        y (int): y coordinate of the direction
    &#34;&#34;&#34;
    self.rotation = degrees(atan2(y - self.y, x - self.x))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygreenfoot" href="index.html">pygreenfoot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygreenfoot.actor.Actor" href="#pygreenfoot.actor.Actor">Actor</a></code></h4>
<ul class="">
<li><code><a title="pygreenfoot.actor.Actor.act" href="#pygreenfoot.actor.Actor.act">act</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_actors_at_offset" href="#pygreenfoot.actor.Actor.get_actors_at_offset">get_actors_at_offset</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_actors_at_offset_generator" href="#pygreenfoot.actor.Actor.get_actors_at_offset_generator">get_actors_at_offset_generator</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_actors_in_range" href="#pygreenfoot.actor.Actor.get_actors_in_range">get_actors_in_range</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_actors_in_range_generator" href="#pygreenfoot.actor.Actor.get_actors_in_range_generator">get_actors_in_range_generator</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_image" href="#pygreenfoot.actor.Actor.get_image">get_image</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_intersecting_actors" href="#pygreenfoot.actor.Actor.get_intersecting_actors">get_intersecting_actors</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_intersecting_actors_generator" href="#pygreenfoot.actor.Actor.get_intersecting_actors_generator">get_intersecting_actors_generator</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_neighbours" href="#pygreenfoot.actor.Actor.get_neighbours">get_neighbours</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_neighbours_generator" href="#pygreenfoot.actor.Actor.get_neighbours_generator">get_neighbours_generator</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_one_actor_at_offset" href="#pygreenfoot.actor.Actor.get_one_actor_at_offset">get_one_actor_at_offset</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.get_world" href="#pygreenfoot.actor.Actor.get_world">get_world</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.intersects" href="#pygreenfoot.actor.Actor.intersects">intersects</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.is_at_edge" href="#pygreenfoot.actor.Actor.is_at_edge">is_at_edge</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.is_touching" href="#pygreenfoot.actor.Actor.is_touching">is_touching</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.move" href="#pygreenfoot.actor.Actor.move">move</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.on_world_add" href="#pygreenfoot.actor.Actor.on_world_add">on_world_add</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.on_world_remove" href="#pygreenfoot.actor.Actor.on_world_remove">on_world_remove</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.remove_touching" href="#pygreenfoot.actor.Actor.remove_touching">remove_touching</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.repaint" href="#pygreenfoot.actor.Actor.repaint">repaint</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.rotation" href="#pygreenfoot.actor.Actor.rotation">rotation</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.set_image" href="#pygreenfoot.actor.Actor.set_image">set_image</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.set_position" href="#pygreenfoot.actor.Actor.set_position">set_position</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.turn_towards" href="#pygreenfoot.actor.Actor.turn_towards">turn_towards</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.x" href="#pygreenfoot.actor.Actor.x">x</a></code></li>
<li><code><a title="pygreenfoot.actor.Actor.y" href="#pygreenfoot.actor.Actor.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>